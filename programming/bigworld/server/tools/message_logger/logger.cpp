#include "logger.hpp"

#include "constants.hpp"
#include "log_storage.hpp"
#include "mlutil.hpp"
#include "mldb/log_storage.hpp"
#if defined(HAS_MONGODB_SUPPORT)
#include "mongodb/log_storage.hpp"
#endif

#include "server/bwconfig.hpp"
#include "server/bwservice.hpp"
#include "server/config_reader.hpp"

#include "network/logger_message_forwarder.hpp"
#include "network/machined_utils.hpp"
#include "network/network_interface.hpp"
#include "network/portmap.hpp"

#include "cstdmf/bw_util.hpp"
#include "cstdmf/debug.hpp"
#include "cstdmf/debug_filter.hpp"
#include "cstdmf/dprintf.hpp"
#include "cstdmf/profiler.hpp"
#include "cstdmf/timestamp.hpp"

#include <time.h>
#include <sys/resource.h>
#include <sys/syslog.h>

#if defined(__unix__)
#include "pwd.h"
#endif

#include <algorithm>

DECLARE_DEBUG_COMPONENT(0)

BW_BEGIN_NAMESPACE

namespace // anonymous
{

    static const int PROFILER_UPDATE_DELAY = 1000000 / 20; /* 1/20 sec */

    const char* USAGE_MESSAGE =
      "\n"
      "Usage: logger [options] [outdir]\n"
      "options:\n"
      " -h, --help    Print this message and exit.\n"
      " -u UID        Log only messages from processes run by the user\n"
      "                with uid = UID. If UID is \"all\", messages from\n"
      "                all users will be logged. If no uid is specified,\n"
      "                processes by all users will be logged.\n"
      " -p NAME       Log messages from processes with name NAME. Multiple\n"
      "                names may be specified using multiple -p options. By\n"
      "                default, messages from processes of any name are\n"
      "                logged. Appropriate names include: CellAppMgr, "
      "CellApp,\n"
      "                BaseApp, BaseAppMgr, DBApp, LoginApp, WPGen. -p and\n"
      "                -d options can not be used at same time.\n"
      " -d NAME       Do not log messages from processes with name NAME.\n"
      "                Multiple names may be specified using multiple -d\n"
      "                options. By default messages from processes of any\n"
      "                name are logged. -d and -p options can not be used\n"
      "                at same time.\n"
      " -l LoggerID   If set, log only messages destined for this LoggerID.\n"
      "                Logs for the Tools process type do not have a logger "
      "ID\n"
      "                associated with them and will not be filtered out "
      "(this\n"
      "                allows server start messages to be recorded and "
      "enables\n"
      "                log-viewing functionality from the last server start\n"
      "                time).\n"
      " -v            Verbose mode. Prints all messages to standard output.\n"
      " --version     Display version information.\n"
      " --daemon      Run as daemon.\n"
      " --chdir directory   Change current working directory.\n"
      " --pid path    Set path for PID file.\n"
      " -s storageType  Storage type of log database. Valid options are mldb "
      "or\n"
      "               mongodb. If the storageType is not specifed the value\n"
      "               will be read from the message logger config file, or if\n"
      "               not found then the default type is mldb.\n"
      " -c|--config <conffile>\n"
      "               Specify config file to use.\n"
      " -t|--text     Generate text logs as well as binary logs\n"
      " -q|--quiet    Quiet Mode. Do not display message generated by this\n"
      "               process. By default, these are output to standard "
      "error.\n"
      " -o filename	Redirect standard output to filename.\n"
      " -e filename	Redirect standard error to filename.\n"
      " -[TRACE|DEBUG|INFO|NOTICE|WARNING|ERROR|CRITICAL|HACK|ASSET]\n"
      "               Disable logging of specific type of message.\n"
      " +[TRACE|DEBUG|INFO|NOTICE|WARNING|ERROR|CRITICAL|HACK|ASSET]\n"
      "               Enable logging of specific type of message. The first\n"
      "               option of this type disables logging of other messages.\n"
      "\n"
      "outdir         Output will be stored in this directory (only for "
      "mldb).\n";

    // -----------------------------------------------------------------------------
    // Section: Logger
    // -----------------------------------------------------------------------------

    Logger* g_pInstance_;

    // The number of seconds until the [Groups] from a machine should be
    // required to ensure they haven't changed.
    const uint SECONDS_TILL_GROUP_REQUERY = 60;

    const BW::string STORAGE_TYPE_MLDB    = "mldb";
    const BW::string STORAGE_TYPE_MONGODB = "mongodb";

    const MessageLogger::NetworkVersion
      OLDEST_SUPPORTED_MESSAGE_LOGGER_VERSION = 7;

    enum SendAddType
    {
        SHOULD_USE_UDP = 0,
        SHOULD_USE_TCP,
        SHOULD_USE_TCP_WITH_METADATA_V2_9,
        SHOULD_USE_TCP_WITH_METADATA_V14_4
    };

} // end anonymous namespace

/**
 *	Constructor.
 */
Logger::Logger()
  : WatcherRequestHandler()
  , watcherNub_()
  , dispatcher_()
  , loggerID_()
  , logUser_(getUserId())
  , logAllUsers_(true)
  , logNames_()
  , doNotLogNames_()
  , quietMode_(true)
  , daemonMode_(false)
  , shouldRoll_(false)
  , shouldValidateHostnames_(false)
  , shouldWriteToStdout_(false)
  , addLoggerData_()
  , addLoggerDataTCP_()
  , addLoggerDataTCPWithMetaDataV2_9_()
  , addLoggerDataTCPWithMetaDataV14_4_()
  , delLoggerData_()
  , storageType_()
  , pidPath_()
  , components_()
  , pLogStorage_(NULL)
  , workingDirectory_()
  , rootLogDirectory_()
  , isMongoDBDriverInitialised_(false)
{
    g_pInstance_ = this;
#if ENABLE_PROFILER
    g_profiler.init(12 * 1024 * 1024);
#endif // ENABLE_PROFILER

    for (uint32 i = 0; i < NUM_MESSAGE_PRIORITY; ++i) {
        shouldLogMessagePriority_[i] = true;
    }

    MF_WATCH("size", *this, &Logger::size);
    MF_WATCH(
      "reattachAll", *this, MF_ACCESSORS(bool, Logger, commandReattachAll));
    {
        MF_WATCH(
          "filter/threshold",
          DebugFilter::instance(),
          MF_ACCESSORS(DebugMessagePriority, DebugFilter, filterThreshold));
        MF_WATCH("filter/TRACE",
                 shouldLogMessagePriority_[MESSAGE_PRIORITY_TRACE]);
        MF_WATCH("filter/DEBUG",
                 shouldLogMessagePriority_[MESSAGE_PRIORITY_DEBUG]);
        MF_WATCH("filter/INFO",
                 shouldLogMessagePriority_[MESSAGE_PRIORITY_INFO]);
        MF_WATCH("filter/NOTICE",
                 shouldLogMessagePriority_[MESSAGE_PRIORITY_NOTICE]);
        MF_WATCH("filter/WARNING",
                 shouldLogMessagePriority_[MESSAGE_PRIORITY_WARNING]);
        MF_WATCH("filter/ERROR",
                 shouldLogMessagePriority_[MESSAGE_PRIORITY_ERROR]);
        MF_WATCH("filter/CRITICAL",
                 shouldLogMessagePriority_[MESSAGE_PRIORITY_CRITICAL]);
        MF_WATCH("filter/HACK",
                 shouldLogMessagePriority_[MESSAGE_PRIORITY_HACK]);
        MF_WATCH("filter/SCRIPT",
                 shouldLogMessagePriority_[DEPRECATED_PRIORITY_SCRIPT]);
        MF_WATCH("filter/ASSET",
                 shouldLogMessagePriority_[MESSAGE_PRIORITY_ASSET]);
    }

    MapWatcher<Components>* pWatchComponents =
      new MapWatcher<Components>(components_);
    pWatchComponents->addChild(
      "*", new BaseDereferenceWatcher(Component::pWatcher()));
    Watcher::rootWatcher().addChild("components", pWatchComponents);
}

bool Logger::parseCommandLine(int argc, char* argv[])
{
    bool        hadPlusOption = false;
    const char* config        = NULL;

    // parse command line.
    for (int i = 1; i < argc; ++i) {
        BW::string arg(argv[i]);

        if (argv[i][0] == '-') {
            if (arg == "--pid") {
                ++i;
                if (i >= argc) {
                    ERROR_MSG("Invalid command line - no argument for --pid\n");
                } else {
                    // Set PID file to this path
                    pidPath_ = argv[i];
                }
            } else if (arg == "-h" || arg == "--help") {
                DebugFilter::shouldWriteToConsole(true);
                DebugFilter::shouldWriteTimePrefix(false);
                dprintf("%s", USAGE_MESSAGE);
                DebugFilter::shouldWriteToConsole(false);
                exit(EXIT_SUCCESS);
            } else if ((arg == "-q") || (arg == "--quiet")) {
                quietMode_ = true;
                DebugFilter::shouldWriteToConsole(false);
            } else if (arg == "-v") {
                shouldWriteToStdout_ = true;
            } else if (arg == "--version") {
                const BW::string& bwversion = BWVersion::versionString();
#if defined(HAS_MONGODB_SUPPORT)
                printf("MessageLogger (BigWorld %s %s. %s %s)\n"
                       "Protocol version %d\n"
                       "MLDB log format version %d\n"
                       "MongoDB log format version %d\n",
                       bwversion.c_str(),
                       MF_CONFIG,
                       __TIME__,
                       __DATE__,
                       MESSAGE_LOGGER_VERSION,
                       LOG_FORMAT_VERSION,
                       MongoDB::SCHEMA_VERSION);
                exit(EXIT_SUCCESS);
#else
                printf("MessageLogger (BigWorld %s %s. %s %s)\n"
                       "Protocol version %d\n"
                       "MLDB log format version %d\n"
                       "MongoDB is not supported in this build\n",
                       bwversion.c_str(),
                       MF_CONFIG,
                       __TIME__,
                       __DATE__,
                       MESSAGE_LOGGER_VERSION,
                       LOG_FORMAT_VERSION);
                exit(EXIT_SUCCESS);
#endif // defined( HAS_MONGODB_SUPPORT )
            } else if (arg == "-p") {
                ++i;
                if (i >= argc) {
                    ERROR_MSG("Invalid command line - no argument for -p\n");
                } else {
                    logNames_.push_back(argv[i]);
                }
            } else if (arg == "-d") {
                ++i;

                if (i >= argc) {
                    ERROR_MSG("Invalid command line - no argument for -d\n");
                } else {
                    doNotLogNames_.push_back(argv[i]);
                }
            } else if (arg == "-o") {
                ++i;

                if (i >= argc) {
                    ERROR_MSG(
                      "Invalid command line - no file specified for -o\n");
                    return false;
                } else {
                    outputFilename_ = argv[i];

                    if (outputFilename_.c_str()[0] != '/') {
                        ERROR_MSG("output filename isn't an absolute path\n");
                        return false;
                    }
                }
            } else if (arg == "-e") {
                ++i;

                if (i >= argc) {
                    ERROR_MSG(
                      "Invalid command line - no file specified for -e\n");
                    return false;
                } else {
                    errorFilename_ = argv[i];

                    if (errorFilename_.c_str()[0] != '/') {
                        ERROR_MSG(
                          "error output filename isn't an absolute path\n");
                        return false;
                    }
                }
            } else if (arg == "-l") {
                ++i;

                if (i >= argc) {
                    ERROR_MSG("Invalid command line - no argument for -l\n");
                    return false;
                } else {
                    loggerID_.assign(argv[i]);
                }
            } else if (arg == "-u") {
                ++i;
                if (i >= argc) {
                    ERROR_MSG("Invalid command line - no argument for -u\n");
                    return false;
                } else {
                    arg = argv[i];
                    if (arg == "all") {
                        logAllUsers_ = true;
                    } else {
                        logUser_     = atoi(arg.c_str());
                        logAllUsers_ = false;
                    }
                }
            } else if (arg == "-c" || arg == "--config") {
                ++i;
                if (i >= argc) {
                    ERROR_MSG("Invalid command line\n");
                    return false;
                } else {
                    config = argv[i];
                }
            } else if (arg == "--daemon") {
                daemonMode_ = true;
            } else if (arg == "--chdir") {
                ++i;
                if (i >= argc) {
                    ERROR_MSG("Invalid command line\n");
                    return false;
                } else {
                    workingDirectory_ = argv[i];
                }
            } else if (arg == "-s") {
                ++i;
                if (i >= argc) {
                    ERROR_MSG("Invalid command line\n");
                    return false;
                } else {
                    storageType_ = argv[i];
                }
            } else {
                char buf[128];
                bw_snprintf(buf, sizeof(buf), "filter/%s", arg.c_str() + 1);
                if (!Watcher::rootWatcher().setFromString(NULL, buf, "false")) {
                    ERROR_MSG("Unknown option %s\n", arg.c_str());
                    return false;
                } else {
                    INFO_MSG("Ignoring logs with message priority '%s'.\n",
                             arg.c_str() + 1);
                }
            }
        } else if (arg[0] == '+') {
            if (!hadPlusOption) {
                hadPlusOption = true;
                for (uint32 i = 0; i < NUM_MESSAGE_PRIORITY; ++i) {
                    shouldLogMessagePriority_[i] = false;
                }
            }

            char buf[128];
            bw_snprintf(buf, sizeof(buf), "filter/%s", arg.c_str() + 1);
            if (!Watcher::rootWatcher().setFromString(NULL, buf, "true")) {
                ERROR_MSG("Unknown option %s\n", arg.c_str());
                return false;
            } else {
                INFO_MSG("Restricting logging to message priority '%s'.\n",
                         arg.c_str() + 1);
            }
        } else {
            if (arg[0] != '\0') {
                rootLogDirectory_ = argv[i];
            }
        }
    }

    // Use the provided config file otherwise discover where the config file
    // we should be using is located.
    if (config != NULL) {
        configFile_ = config;
    } else {
        // Find the location of the config file we should be using.
        if (!MLUtil::determinePathToConfig(configFile_)) {
            ERROR_MSG("Logger::init: Unable to determine where to find config "
                      "file.\n");
            return false;
        }
    }

    return true;
}

/**
 * This method initialises the logger.
 *
 * @return true on success, otherwise false.
 */
bool Logger::init(int argc, char* argv[])
{
#if ENABLE_PROFILER
    this->startProfilerUpdateTimer();
#endif // ENABLE_PROFILER

    interfaceName_ =
      BWConfig::get("message_logger/monitoringInterface",
                    BWConfig::get("monitoringInterface",
                                  Mercury::NetworkInterface::USE_BWMACHINED));

    // This string collects interface discovery information to be displayed
    // once file descriptors have been re-assigned to log files when running
    // in daemon mode.
    BW::string ifProbeStr;

    if (interfaceName_ == Mercury::NetworkInterface::USE_BWMACHINED) {
        // Creating a temporary Nub to query bwmachined for what it
        // knows to be the internalInterface.
        u_int32_t addr;
        bool isOk = Mercury::MachineDaemon::queryForInternalInterface(addr);

        if (!isOk) {
            ERROR_MSG("Logger::init: Failed to look up internal"
                      "interface from BWmachined.\n");

            // Message Logger should exit upon interface lookup failure from
            // bwmachined
            return false;
        }

        interfaceName_ = inet_ntoa((struct in_addr&)addr);
        ifProbeStr.append("Discovered network interface '");
        ifProbeStr.append(interfaceName_.c_str());
        ifProbeStr.append("'\n");
    }

    if (interfaceName_.empty()) {
        ifProbeStr.append(
          "Logger::init: Assuming monitoringInterface of eth0\n");
        interfaceName_ = "eth0";
    }

    ifProbeStr.append("Logger::init: interfaceName = '");
    ifProbeStr.append(interfaceName_.c_str());
    ifProbeStr.append("'\n");
    watcherNub_.init(interfaceName_.c_str(), 0);
    watcherNub_.attachTo(dispatcher_);

    u_int16_t localPort = 0;
    u_int32_t localIP   = 0;
    this->socket().getlocaladdress(&localPort, &localIP);
    Mercury::Address localAddr(localIP, localPort);

    // watcherNub_.socket().setnonblocking( false );

    // Set maximum receive buffer size for logger.
    // Provide a default recvbuf size in case /proc/sys/net/core/rmem_max
    // does not exist.
    // The default value of 21992 was obtained by reading this file on
    // a machine running CentOS 7.1.

    int recvbuf = 212992;

    FILE* pFile = fopen("/proc/sys/net/core/rmem_max", "r");

    if (pFile != NULL) {
        fscanf(pFile, "%d", &recvbuf);
        fclose(pFile);
    }

    setsockopt(this->socket().fileno(),
               SOL_SOCKET,
               SO_RCVBUF,
               (const char*)&recvbuf,
               sizeof(int));

    watcherNub_.setRequestHandler(this);

    DebugFilter::shouldWriteToConsole(true);
    DebugFilter::shouldWriteTimePrefix(true);

    if (!this->parseCommandLine(argc, argv)) {
        return false;
    }

    ConfigReader mlconfig(configFile_.c_str());
    if (!mlconfig.read()) {
        ERROR_MSG("Logger::init: Unable to read configuration file\n");
        return false;
    }

    BW::string value;
    if (mlconfig.getValue("message_logger", "groups", value)) {
        ConfigReader::separateLine(value, ',', groupNames_);
    }

    if ((!rootLogDirectory_.empty()) && (rootLogDirectory_[0] != '/')) {
        ERROR_MSG("Logger::init: Log directory must be an absolute path\n");
        return false;
    }

    if ((!workingDirectory_.empty()) && (workingDirectory_[0] != '/')) {
        ERROR_MSG("Logger::init: Working directory must be an absolute path\n");
        return false;
    }

#ifndef _WIN32
    if (daemonMode_) {
        daemon(0, int(DebugFilter::shouldWriteToConsole()));
    }
#endif

    this->resetFileDescriptors();

    START_MSG("message_logger");

    // Only create PID file if path is present in arguments or config. And
    // create PID file as early as possible as systemd rely on this to maintain
    // service status. If this is created too late, systemd may assume that
    // the service is not started successfully.
    if (!pidPath_.empty()) {
        char* mode = "a+";
        // Make sure another logger isn't already running
        if (!pid_.init(pidPath_.c_str(), mode, mf_getpid())) {
            ERROR_MSG("Logger::init: Another logger instance seems to be"
                      "running. PID file mismatch in %s\n",
                      pidPath_.c_str());
            return false;
        }
    }

    // Now display all the interface discovery information
    {
        int offset = 0;
        int pos    = ifProbeStr.find('\n', offset);
        while (pos != -1) {
            INFO_MSG("%s",
                     ifProbeStr.substr(offset, (pos + 1) - offset).c_str());

            offset = pos + 1;
            pos    = ifProbeStr.find('\n', offset);
        }
    }

    // Display information from option parsing now to avoid corrupting the
    // init.d output.
    if (logAllUsers_) {
        INFO_MSG("Logging all users\n");
    } else {
        INFO_MSG("Logging user id %d\n", logUser_);
    }

    if (!loggerID_.empty()) {
        INFO_MSG("Logging messages destined only for LoggerID: \"%s\"\n",
                 loggerID_.c_str());

        if (loggerID_ == "0") {
            // The old 1.9 default, warn if this is not the intended behaviour.
            WARNING_MSG(
              "Logger::init: Logger ID is set to \"0\", previously "
              "this meant to match all. This behaviour is now specified "
              "by an empty string as the Logger ID.\n");
        }
    }

    if (storageType_.empty()) {
        BW::string tmpString;
        if (mlconfig.getValue("message_logger", "storage_type", tmpString)) {
            storageType_ = tmpString.c_str();
        } else {
            storageType_ = STORAGE_TYPE_MLDB;
        }
    }

    if (storageType_ == STORAGE_TYPE_MLDB) {
        pLogStorage_ = new LogStorageMLDB(*this);
    } else if (storageType_ == STORAGE_TYPE_MONGODB) {
#ifdef HAS_MONGODB_SUPPORT
        if (!LogStorageMongoDB::initMongoDBDriver()) {
            ERROR_MSG("Logger::init: Failed to initialize MongoDB driver.\n");
            return false;
        }

        isMongoDBDriverInitialised_ = true;
        pLogStorage_                = new LogStorageMongoDB(*this);
#else
        ERROR_MSG("Logger::init: MessageLogger was compiled on a system that "
                  "doesn't support MongoDB.\n");
        return false;
#endif
    } else {
        ERROR_MSG("Logger::init: Invalid storage type.\n");
        return false;
    }

    INFO_MSG("Using storage type: '%s'\n", storageType_.c_str());

    // Have to init the log after the fork() to get the correct PID.
    if (!pLogStorage_->init(mlconfig, rootLogDirectory_.c_str())) {
        ERROR_MSG("Logger::init: BWLog init failed\n");
        return false;
    }

    if (shouldWriteToStdout_) {
        pLogStorage_->writeToStdout(true);
    }

    // Must start after daemon call so that we get the correct PID.
    {
        if (watcherNub_.registerWatcher(
              0, MESSAGE_LOGGER_NAME, "MessageLogger") != 0) {
            ERROR_MSG("Logger::init: Failed to register watcher\n");
            return false;
        }
    }

    // Register birth and death listeners.
    {
        ListenerMessage lm;
        lm.port_     = localPort;
        lm.category_ = lm.WATCHER_NUB;
        lm.uid_      = lm.ANY_UID;
        lm.pid_      = mf_getpid();
        lm.name_     = ""; // Match everything.

        // Post data is address salt
        uint16 salt  = 0;
        lm.postAddr_ = BW::string((char*)&salt, 2);

        uint32 msgType;

        // We can't use the logger's main socket to do this registration because
        // of the following:
        // 1. We send the registration message with registerWatcher() above.
        // 2. bwmachined2 receives the registration message and calls
        //    broadcastToListeners() which sends a birth notification to itself.
        // 3. We send the birth listener message.
        // 4. The birth listener message is processed.
        // 5. The birth notification bwmachined sent to itself arrives.
        // 6. The birth notification message is sent back to the logger's main
        //    socket.
        // 7. The death listener sendAndRecv() starts and the notification
        //    message is mistakenly processed as a reply, causing the old error:
        //    ERROR: MGMPacket::read: Not enough bytes on stream (wanted 808)

        // The birth listener.
        lm.param_   = lm.PARAM_IS_MSGTYPE | lm.ADD_BIRTH_LISTENER;
        msgType     = MESSAGE_LOGGER_PROCESS_BIRTH;
        lm.preAddr_ = BW::string((char*)&msgType, 4);
        if (lm.sendAndRecvFromEndpointAddr(this->socket(), LOCALHOST) !=
            Mercury::REASON_SUCCESS) {
            ERROR_MSG("Logger::init: Failed to register birth listener!\n");
            return false;
        }

        // The death listener.
        lm.param_   = lm.PARAM_IS_MSGTYPE | lm.ADD_DEATH_LISTENER;
        msgType     = MESSAGE_LOGGER_PROCESS_DEATH;
        lm.preAddr_ = BW::string((char*)&msgType, 4);
        if (lm.sendAndRecvFromEndpointAddr(this->socket(), LOCALHOST) !=
            Mercury::REASON_SUCCESS) {
            ERROR_MSG("Logger::init: Failed to register death listener!\n");
            return false;
        }
    }

    // This is so damn ugly.  An interface for modifying these things should
    // really be written.
    WatcherDataMsg wdm;
    const char*    pWdm = reinterpret_cast<const char*>(&wdm);
    wdm.message         = WATCHER_MSG_SET;
    wdm.count           = 1;

    const char*  localAddrStr = localAddr.c_str();
    const size_t addrSize     = strlen(localAddrStr) + 1;

    addLoggerData_.assign(pWdm, sizeof(wdm));
    addLoggerData_.append("logger/add");
    addLoggerData_.append(1, '\0'); // Add null terminator
    addLoggerData_.append(localAddrStr, addrSize);

    addLoggerDataTCP_.assign(pWdm, sizeof(wdm));
    addLoggerDataTCP_.append("logger/addTCP");
    addLoggerDataTCP_.append(1, '\0'); // Add null terminator
    addLoggerDataTCP_.append(localAddrStr, addrSize);

    addLoggerDataTCPWithMetaDataV2_9_.assign(pWdm, sizeof(wdm));
    addLoggerDataTCPWithMetaDataV2_9_.append("logger/addTCPWithMetaData");
    addLoggerDataTCPWithMetaDataV2_9_.append(1, '\0'); // Add null terminator
    addLoggerDataTCPWithMetaDataV2_9_.append(localAddrStr, addrSize);

    addLoggerDataTCPWithMetaDataV14_4_.assign(pWdm, sizeof(wdm));
    addLoggerDataTCPWithMetaDataV14_4_.append(
      "logger/addTCPWithMetaDataStream");
    addLoggerDataTCPWithMetaDataV14_4_.append(1, '\0'); // Add null terminator
    addLoggerDataTCPWithMetaDataV14_4_.append(localAddrStr, addrSize);

    delLoggerData_.assign(pWdm, sizeof(wdm));
    delLoggerData_.append("logger/del");
    delLoggerData_.append(1, '\0'); // Add null terminator
    delLoggerData_.append(localAddrStr, addrSize);

    this->initClusterGroups();
    this->initComponents();

    // Core files are written to the current working directory. Enable after
    // parsing the config file so we have directory with write permission.
    if (workingDirectory_.empty()) {
        if (!rootLogDirectory_.empty()) {
            if (chdir(rootLogDirectory_.c_str()) == -1) {
                ERROR_MSG("Logger::init: Failed to change directory to %s\n",
                          rootLogDirectory_.c_str());
                return false;
            }
        } else if (mlconfig.getValue("mldb", "logdir", value)) {
            if (chdir(value.c_str()) == -1) {
                ERROR_MSG("Logger::init: Failed to change directory to %s\n",
                          value.c_str());
                return false;
            }
        }
    } else if (chdir(workingDirectory_.c_str()) == -1) {
        ERROR_MSG("Logger::init: Failed to change directory to %s\n",
                  workingDirectory_.c_str());
        return false;
    }

    rlimit rlimitData = { RLIM_INFINITY, RLIM_INFINITY };
    if (setrlimit(RLIMIT_CORE, &rlimitData) == -1) {
        ERROR_MSG("Unable to set core file privileges: %s\n", strerror(errno));
        return false;
    }

    return true;
}

/**
 *	Destructor.
 */
Logger::~Logger()
{
    // Detach all
    {
        // TODO: We should add a timeout so that components attached to the
        // logger will timeout if they haven't received a ping (addComponent)
        // every so often.
        Components::const_iterator iter = components_.begin();

        while (iter != components_.end()) {
            Mercury::Address addr = iter->first;
            ++iter;

            this->delComponent(addr);
        }
    }

    // If the PID file is the same as our process, delete it.
    if (pid_.getValue() == mf_getpid()) {
        // Clean up the PID file so someone else can write here
        if (bw_unlink(pid_.filename())) {
            ERROR_MSG("Logger::~Logger(): "
                      "Unable to remove PID file '%s': %s\n",
                      pid_.filename(),
                      strerror(errno));
        }
    }

    if (pLogStorage_ != NULL) {
        delete pLogStorage_;
    }

#ifdef HAS_MONGODB_SUPPORT
    if (isMongoDBDriverInitialised_) {
        LogStorageMongoDB::shutdownMongoDBDriver();
    }
#endif

    g_pInstance_ = NULL;
    profilerTimer_.cancel();
#if ENABLE_PROFILER
    g_profiler.fini();
#endif // ENABLE_PROFILER
}

/**
 *	This method processes the next network packet.
 *
 *	@returns The number of messages processed.
 */
bool Logger::handleNextMessage()
{
    pLogStorage_->tick();

    // If a log rolling is scheduled, do it now
    if (shouldRoll_) {
        if (!pLogStorage_->roll()) {
            ERROR_MSG("Logger::handleNextMessage: "
                      "Failed to roll component logs\n");
        }

        this->resetFileDescriptors();

        shouldRoll_ = false;
    }

    if (shouldValidateHostnames_) {
        if (pLogStorage_->validateNextHostname() !=
            BW_VALIDATE_HOSTNAMES_CONTINUE) {
            shouldValidateHostnames_ = false;
        }
    }

    // Do not idle whilst validating hostnames. Allow the next one to
    // validate even if there are no messages.
    int numMessagesProcessed = dispatcher_.processOnce(
      /* shouldIdle */ !shouldValidateHostnames_);

    return (numMessagesProcessed > 0 ||
            (shouldValidateHostnames_ && numMessagesProcessed == 0));
}

/**
 * Shutdown and re-open any files being used to redirect stdout/stderr.
 *
 * @returns true on success, false on error.
 */
bool Logger::resetFileDescriptors()
{
    int    defFlags = O_APPEND | O_CREAT | O_WRONLY;
    mode_t defMode  = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
    bool   status   = true;

    // TODO: should we test the open/append/create before daemon so we can
    //      die with some message to stdout
    if (outputFilename_.length()) {
        int ofd = open(outputFilename_.c_str(), defFlags, defMode);
        if (ofd == -1) {
            ERROR_MSG("Failed to open '%s' for redirecting stdout: %s\n",
                      outputFilename_.c_str(),
                      strerror(errno));
            status = false;
        } else {
            MF_ASSERT(ofd != 1);
            // dup2 will now shutdown stdout and duplicate the output file fd.
            if (-1 == dup2(ofd, 1)) {
                ERROR_MSG("Failed to dup2 '%s' to stdout. %s.\n",
                          outputFilename_.c_str(),
                          strerror(errno));
                status = false;
            }

            // shutdown the temporary fd now that stdout owns it
            close(ofd);
        }
    }

    if (errorFilename_.length()) {
        if (errorFilename_ == outputFilename_) {
            if (-1 == dup2(1, 2)) {
                ERROR_MSG("Failed to dup2 stdout to stderr. %s.\n",
                          strerror(errno));
                status = false;
            }
        } else {
            int efd = open(errorFilename_.c_str(), defFlags, defMode);
            if (efd == -1) {
                ERROR_MSG("Failed to open '%s' for redirecting stderr: %s\n",
                          errorFilename_.c_str(),
                          strerror(errno));
                status = false;
            } else {

                MF_ASSERT(efd != 2);
                // dup2 will now shutdown stderr and duplicate
                // the error file fd.
                if (-1 == dup2(efd, 2)) {
                    ERROR_MSG("Failed to dup2 '%s' to stderr. %s.\n",
                              errorFilename_.c_str(),
                              strerror(errno));
                    status = false;
                }

                // shutdown the temporary fd now that stderr owns it
                close(efd);
            }
        }
    }

    // Throw an error message so any syslog monitoring will catch the errors
    if (!status) {
        ERROR_MSG("Logging may no longer work.");
    }

    return status;
}

/**
 *  This method starts the timer for profiler update.
 */
void Logger::startProfilerUpdateTimer()
{
    MF_ASSERT(!profilerTimer_.isSet());
    profilerTimer_ =
      dispatcher_.addTimer(PROFILER_UPDATE_DELAY,
                           this,
                           reinterpret_cast<void*>(TIMEOUT_PROFILER_UPDATE),
                           "ProfilerUpdate");
}

/**
 *	This method handles timeout events.
 */
void Logger::handleTimeout(TimerHandle /*handle*/, void* arg)
{
    uintptr timerType = reinterpret_cast<uintptr>(arg);
    switch (timerType) {
        case TIMEOUT_PROFILER_UPDATE:
#if ENABLE_PROFILER
            g_profiler.tick();
#endif // ENABLE_PROFILER
            break;
    }
}

// -----------------------------------------------------------------------------
// Section: Machine Guard
// -----------------------------------------------------------------------------
class TagsHandler : public MachineGuardMessage::ReplyHandler
{
  public:
    /**
     *	Constructor.
     */
    TagsHandler(Logger& logger)
      : logger_(logger)
    {
    }

    virtual bool onTagsMessage(TagsMessage&             tm,
                               MessageLogger::IPAddress ipAddress);

  private:
    Logger& logger_;
};

/*
 *	Override from MachineGuardMessage::ReplyHandler.
 */
bool TagsHandler::onTagsMessage(TagsMessage&             tm,
                                MessageLogger::IPAddress ipAddress)
{
    // Regardless of whether the machine had groups or not, we still
    // need to update the MachineGroups entry.
    Logger::MachineGroups* machineGroups = logger_.machineGroups_[ipAddress];

    if (machineGroups == NULL) {
        machineGroups = new Logger::MachineGroups;

        logger_.machineGroups_[ipAddress] = machineGroups;
    }

    if (!tm.exists_) {
        machineGroups->groups_.clear();
    } else {
        machineGroups->groups_ = tm.tags_;
    }

    // The last poll time for the machine should be slightly randomised to
    // avoid requerying all machines at the same time.
    machineGroups->lastPollTime_ = (timestamp() / stampsPerSecond()) +
                                   (int)(10.0 * (rand() / (RAND_MAX + 1.0)));

    return true;
}

/**
 *	This class is a helper for finding processes.
 */
class FindHandler : public MachineGuardMessage::ReplyHandler
{
  public:
    /**
     *	Constructor.
     */
    FindHandler(Logger& logger)
      : logger_(logger)
    {
    }

    virtual bool onProcessStatsMessage(ProcessStatsMessage&     psm,
                                       MessageLogger::IPAddress ipAddress);

  private:
    Logger& logger_;
};

/*
 *	Override from MachineGuardMessage::ReplyHandler.
 */
bool FindHandler::onProcessStatsMessage(ProcessStatsMessage&     psm,
                                        MessageLogger::IPAddress ipAddress)
{
    if (psm.pid_ == 0) {
        return true;
    }

    // We don't want to try to log other message loggers ...
    if (psm.name_ == "message_logger") {
        return true;
    }

    Mercury::Address address(ipAddress, psm.port_);

    SendAddType sendType;

    if (psm.majorVersion_ > 2 ||
        (psm.majorVersion_ == 2 && psm.minorVersion_ >= 9)) {
        if (psm.minorVersion_ == 9) {
            sendType = SHOULD_USE_TCP_WITH_METADATA_V2_9;
        } else {
            sendType = SHOULD_USE_TCP_WITH_METADATA_V14_4;
        }
    } else if (psm.majorVersion_ > 2 ||
               (psm.majorVersion_ == 2 && psm.minorVersion_ >= 6)) {
        sendType = SHOULD_USE_TCP;
    } else {
        sendType = SHOULD_USE_UDP;
    }

    if (logger_.sendAdd(address, sendType)) {
        INFO_MSG("Logger::onProcessStatsMessage: Found %s at %s. uid = %d\n",
                 psm.name_.c_str(),
                 address.c_str(),
                 psm.uid_);
    }
    return true;
}

/**
 *	This method finds all components that are currently running on the network.
 */
void Logger::initComponents()
{
    ProcessStatsMessage psm;
    psm.param_    = psm.PARAM_USE_CATEGORY;
    psm.category_ = psm.WATCHER_NUB;

    if (!logAllUsers_) {
        psm.param_ |= psm.PARAM_USE_UID;
        psm.uid_ = logUser_;
    }

    // Do broadcast and read back replies
    FindHandler handler(*this);
    if (!this->createEndpointAndQueryMsg(psm, BROADCAST, handler)) {
        ERROR_MSG("Logger::initComponents: Failed to find existing cluster "
                  "components.\n");
    }
}

/**
 * Queries the entire cluster for their groups.
 */
void Logger::initClusterGroups()
{
    // No need to query the cluster if we aren't monitoring sub-groups
    if (groupNames_.empty()) {
        return;
    }

    MessageLogger::StringList::const_iterator groupIter = groupNames_.begin();
    BW::string                                groupConcat;
    while (groupIter != groupNames_.end()) {
        groupConcat.append(*groupIter + " ");
        groupIter++;
    }
    INFO_MSG("Logger::init: MessageLogger machine groups specified. Only "
             "accepting logs from: %s\n",
             groupConcat.c_str());

    // Query the machine for any Groups it has
    TagsMessage tm;
    tm.tags_.push_back("Groups");

    TagsHandler handler(*this);
    if (!this->createEndpointAndQueryMsg(tm, BROADCAST, handler)) {
        ERROR_MSG("Logger::initClusterGroups: Unable to query "
                  "bwmachined on source of potential logs. ");
    }
}

// -----------------------------------------------------------------------------
// Section: Message handlers
// -----------------------------------------------------------------------------

/**
 *	This method overrides the WatcherRequestHandler method to handle extension
 *	messages.
 */
void Logger::processExtensionMessage(int              messageID,
                                     char*            data,
                                     int              dataLen,
                                     WatcherEndpoint& watcherEndpoint)
{
    Mercury::Address addr = watcherEndpoint.remoteAddr();
    switch (messageID) {
        case MESSAGE_LOGGER_MSG: {
            MemoryIStream is(data, dataLen);
            this->handleLogMessage(is, addr, watcherEndpoint);

            // Prevent lots of output about memory stream still containing data
            is.finish();

            break;
        }

        case MESSAGE_LOGGER_REGISTER: {
            this->handleRegisterRequest(data, dataLen, addr, watcherEndpoint);
            break;
        }

        case MESSAGE_LOGGER_PROCESS_BIRTH: {
            if (dataLen == sizeof(Mercury::Address)) {
                Mercury::Address addr = *(Mercury::Address*)data;
                this->handleBirth(addr);
            } else {
                ERROR_MSG("Logger::processExtensionMessage: "
                          "Bad birth size %d\n",
                          dataLen);
            }
            break;
        }

        case MESSAGE_LOGGER_PROCESS_DEATH: {
            if (dataLen == sizeof(Mercury::Address)) {
                Mercury::Address deadAddr = *(Mercury::Address*)data;

                // If someone sends INADDR_ANY as the address, just use the
                // source address instead
                if (deadAddr.ip == 0) {
                    deadAddr.ip = addr.ip;
                }

                this->handleDeath(deadAddr);
            } else {
                ERROR_MSG("Logger::processExtensionMessage: "
                          "Bad death size %d\n",
                          dataLen);
            }
            break;
        }

        case MESSAGE_LOGGER_APP_ID: {
            if (dataLen == sizeof(ServerAppInstanceID)) {
                pLogStorage_->setAppInstanceID(addr,
                                               *(ServerAppInstanceID*)data);
            } else {
                ERROR_MSG("Logger::processExtensionMessage: "
                          "Bad app ID size %d\n",
                          dataLen);
            }
            break;
        }

        case WATCHER_MSG_TELL:
            // TODO: We may look at these to know whether adds have worked.
            // Ignore tell messages.
            break;

        default: {
            DEBUG_MSG("Logger::processExtensionMessage: "
                      "Message %d not handled\n",
                      messageID);

            for (int i = 0; i < dataLen; ++i) {
                char c = data[i];
                if ((('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z'))) {
                    DEBUG_MSG("%c\n", c);
                } else {
                    DEBUG_MSG("0x%02d\n", uint8(c));
                }
            }

            break;
        }
    }
}

/**
 *	This method overrides the WatcherRequestHandler method to handle TCP
 *	disconnects
 */
void Logger::processDisconnect(WatcherEndpoint& watcherEndpoint)
{
    Mercury::Address addr = watcherEndpoint.remoteAddr();
    if (components_.find(addr) != components_.end()) {
        this->delComponent(addr, /* send: */ false);
    }
}

/**
 *	This method is called when a process starts that we may want to watch.
 */
void Logger::handleBirth(const Mercury::Address& addr) {}

/**
 *	This method is called when a process stops that we may have been watching.
 */
void Logger::handleDeath(const Mercury::Address& addr)
{
    INFO_MSG("Logger::handleDeath: %s\n", addr.c_str());
    if (components_.find(addr) != components_.end()) {
        this->delComponent(addr, /* send: */ false);
    }
}

/**
 *	This method handles a log message from a component.
 */
void Logger::handleLogMessage(MemoryIStream&          inputStream,
                              const Mercury::Address& address,
                              WatcherEndpoint&        watcherEndpoint)
{
    Components::const_iterator iter = components_.find(address);

    if (iter == components_.end()) {
        WARNING_MSG("Logger::handleLogMessage: "
                    "Got message from unregistered component %s\n",
                    address.c_str());

        // TODO: We should probably send an add here, not a del.  The problem at
        // the moment is that server components compiled with out-of-date logger
        // protocol support (see logger_message_forwarder.hpp) will repeatedly
        // generate this warning if we do a naive add here.  We could maybe
        // cache a map of out-of-date components in handleRegisterRequest()
        // below and only send adds to up-to-date components.
        this->sendDel(watcherEndpoint);
        return;
    }

    LogStorage::AddLogMessageResult addLogMessageResult =
      pLogStorage_->addLogMessage(*iter->second, address, inputStream);

    if (addLogMessageResult == LogStorage::LOG_ADDITION_FAILED) {
        ERROR_MSG("Logger::handleLogMessage: LogStorage::addLogMessage() "
                  "failed, a log entry has been lost!\n");
    }
}

/**
 *	This method handles a request to register a component.
 */
void Logger::handleRegisterRequest(char*                   data,
                                   int                     dataLen,
                                   const Mercury::Address& addr,
                                   WatcherEndpoint&        watcherEndpoint)
{
    MemoryIStream            is(data, dataLen);
    std::auto_ptr<Component> pComponent(new Component(watcherEndpoint));
    pComponent->read(is);

    if (is.error() || is.remainingLength() > 0) {
        ERROR_MSG("Malformed register request from %s\n", addr.c_str());
        return;
    }

    if (this->shouldLogFromGroup(addr) && this->shouldConnect(*pComponent)) {
        INFO_MSG("Registering %s at %s (uid:%d, loggerID:\"%s\")\n",
                 pComponent->name(),
                 addr.c_str(),
                 pComponent->uid_,
                 pComponent->loggerID_.c_str());
        components_[addr] = pComponent.release();
    } else if (strcmp("Client", pComponent->name()) != 0) {
        // Clients aren't listening for incoming watcher requests over the
        // nework so don't keep trying to send it to them.

        WARNING_MSG(
          "Not registering %s at %s\n", pComponent->name(), addr.c_str());
        this->sendDel(watcherEndpoint);
    }
}

/**
 *	This method returns whether or not we should accept the input component.
 */
bool Logger::shouldConnect(const Component& component) const
{
    // make sure client is sending out packets that we know
    // what to do with.
    if (component.version_ < OLDEST_SUPPORTED_MESSAGE_LOGGER_VERSION) {
        WARNING_MSG("Not registering %s (uid:%d) "
                    "(got version %d < oldest supported version = %d)\n",
                    component.componentName_.c_str(),
                    component.uid_,
                    component.version_,
                    OLDEST_SUPPORTED_MESSAGE_LOGGER_VERSION);
        return false;
    }

    if (component.version_ > MESSAGE_LOGGER_VERSION) {
        WARNING_MSG("Process using newer message format asking "
                    "to be logged.. update your logger! %d > %d\n",
                    component.version_,
                    MESSAGE_LOGGER_VERSION);
        return false;
    }

    if (!logAllUsers_ && (logUser_ != component.uid_)) {
        // Not our UID.
        // shouldLog = false;
        return false;
    }

    // The below component name check is a workaround for
    // [BWT-26049]/[BWSUP-120] The fact that Tools components are unable to
    // obtain the logger ID means that Server Start messages may be excluded
    // from being logged, preventing the use of log searching from Server Start.
    if ((component.componentName_ != BW_TOOLS_COMPONENT_NAME) &&
        ((!loggerID_.empty()) && (loggerID_ != component.loggerID_))) {
        // Not correct logger id.
        return false;
    }

    if (!logNames_.empty() &&
        std::find(logNames_.begin(),
                  logNames_.end(),
                  component.componentName_) == logNames_.end()) {
        // Not in valid names.
        return false;
    }

    if (std::find(doNotLogNames_.begin(),
                  doNotLogNames_.end(),
                  component.componentName_) != doNotLogNames_.end()) {
        // Is an invalid name.
        return false;
    }

    return true;
}

bool Logger::shouldLogFromGroup(const Mercury::Address& addr)
{
    bool shouldAccept = true;

    if (!groupNames_.empty()) {
        uint64 currTime = timestamp() / stampsPerSecond();

        // Attempt to locate an existing set of group information for
        // the potential address.
        MachineGroups* currGroups = NULL;
        currGroups                = machineGroups_[addr.ip];

        bool hasExpired =
          ((currGroups != NULL) && ((currTime - currGroups->lastPollTime_) >
                                    SECONDS_TILL_GROUP_REQUERY));

        // It may be necessary to update the [Groups] information for
        // the machine that about to be added.
        if ((currGroups == NULL) || hasExpired) {
            // Query the machine for any Groups it has
            TagsMessage tm;
            tm.tags_.push_back("Groups");

            TagsHandler handler(*this);
            if (!this->createEndpointAndQueryMsg(tm, addr.ip, handler)) {
                if (hasExpired) {
                    WARNING_MSG("Logger::shouldLogFromGroup: Using old "
                                "machine groups. Unable to update.\n");
                } else {
                    ERROR_MSG("Logger::shouldLogFromGroup: Unable to query "
                              "bwmachined on source of potential logs. "
                              "Forgetting %s.\n",
                              addr.c_str());
                    shouldAccept = false;
                }
            }

            currGroups = machineGroups_[addr.ip];
            if (currGroups == NULL)
                shouldAccept = false;
        }

        // Now we are certain the group information from bwmachined is up
        // to date, check whether the requesting machine is on our list
        // of machines to listen to.
        if (shouldAccept) {
            MessageLogger::StringList::iterator ownIter = groupNames_.begin();

            // For the final check we'll invert the should accept and only
            // re-enable it if found.
            shouldAccept = false;

            while ((ownIter != groupNames_.end()) && !shouldAccept) {
                MessageLogger::StringList::iterator responseIter =
                  currGroups->groups_.begin();

                while ((responseIter != currGroups->groups_.end()) &&
                       !shouldAccept) {
                    if (*responseIter == *ownIter)
                        shouldAccept = true;

                    responseIter++;
                }

                ownIter++;
            }
        }
    }

    return shouldAccept;
}

bool Logger::shouldLogPriority(
  MessageLogger::NetworkMessagePriority messagePriority)
{
    if (messagePriority > NUM_MESSAGE_PRIORITY) {
        return false;
    }

    return shouldLogMessagePriority_[messagePriority];
}

// -----------------------------------------------------------------------------
// Section: Misc
// -----------------------------------------------------------------------------

bool Logger::createEndpointAndQueryMsg(
  MachineGuardMessage&               mgm,
  MessageLogger::IPAddress           ipAddress,
  MachineGuardMessage::ReplyHandler& handler)
{
    // Create the socket
    Endpoint ep;
    ep.socket(SOCK_DGRAM);
    u_int32_t ifaddr = INADDR_ANY;
    char      iftemp[IFNAMSIZ];
    ep.findIndicatedInterface(interfaceName_.c_str(), iftemp);
    ep.getInterfaceAddress(iftemp, ifaddr);
    if (!ep.good() || ep.bind(0, ifaddr) != 0) {
        ERROR_MSG("Logger::createEndpointAndQueryMsg: "
                  "Problem setting up socket.\n");
        return false;
    }

    // Query the address with the message
    Mercury::Reason reason = mgm.sendAndRecv(ep, ipAddress, &handler);
    if (reason != Mercury::REASON_SUCCESS) {
        ERROR_MSG("Logger::createEndpointAndQueryMsg: "
                  "MGM::sendAndRecv() failed: %s\n",
                  Mercury::reasonToString(reason));
        return false;
    }

    return true;
}

/**
 *	This method sends an add logger request to the input address.
 */
bool Logger::sendAdd(const Mercury::Address& addr, const int sendType)
{
    if (!this->shouldLogFromGroup(addr)) {
        return false;
    }

    BW::string* pData;

    if (sendType == SHOULD_USE_TCP_WITH_METADATA_V14_4) {
        pData = &addLoggerDataTCPWithMetaDataV14_4_;
    } else if (sendType == SHOULD_USE_TCP_WITH_METADATA_V2_9) {
        pData = &addLoggerDataTCPWithMetaDataV2_9_;
    } else if (sendType == SHOULD_USE_TCP) {
        pData = &addLoggerDataTCP_;
    } else {
        pData = &addLoggerData_;
    }

    this->socket().sendto(
      (char*)pData->data(), pData->size(), addr.port, addr.ip);

    return true;
}

/**
 *	This method sends a del logger request to the input address.
 */
void Logger::sendDel(WatcherEndpoint& watcherEndpoint)
{
    watcherEndpoint.send((char*)delLoggerData_.data(), delLoggerData_.size());
}

/**
 *	This method deletes the attachment that we have with a component.
 */
void Logger::delComponent(const Mercury::Address& addr, bool send)
{
    INFO_MSG("Logger::delComponent: %s\n", addr.c_str());

    if (!pLogStorage_->stopLoggingFromComponent(addr)) {
        ERROR_MSG("Logger::delComponent: "
                  "Failed to stop writing component at %s to the logs\n",
                  addr.c_str());
    }

    Components::iterator iter = components_.find(addr);

    if (iter != components_.end()) {
        if (send) {
            this->sendDel(iter->second->watcherEndpoint());
        }

        delete iter->second;
        components_.erase(iter);
    }
}

/**
 *	This method deletes the attachment that we have with a component.
 */
void Logger::delComponent(Logger::Component* pComponent)
{
    // This is a bit of a brute-force way of doing things (which is probably
    // fine). We could store the address with the component or we could work
    // it out from pComponent since it comes from a map.

    Components::iterator iter = components_.begin();

    while (iter != components_.end()) {
        if (pComponent == iter->second) {
            this->delComponent(iter->first);
            return;
        }

        ++iter;
    }
}

/**
 *	This method refreshes the components that this logger is connected to.
 */
void Logger::commandReattachAll(bool value)
{
    if (value) {
        this->initComponents();
    }
}

// -----------------------------------------------------------------------------
// Section: Logger::Component
// -----------------------------------------------------------------------------

/**
 *	This static method returns a watcher for this type.
 */
WatcherPtr Logger::Component::pWatcher()
{
    static DirectoryWatcherPtr pWatcher = NULL;

    if (pWatcher == NULL) {
        pWatcher         = new DirectoryWatcher();
        Component* pNull = NULL;

        pWatcher->addChild("name",
                           new MemberWatcher<const char*, Logger::Component>(
                             *pNull, &Logger::Component::name));
        pWatcher->addChild("uid", new DataWatcher<uint16>(pNull->uid_));
        pWatcher->addChild("pid", new DataWatcher<uint32>(pNull->pid_));
        pWatcher->addChild(
          "attached",
          new MemberWatcher<bool, Logger::Component>(
            *pNull, MF_ACCESSORS(bool, Logger::Component, commandAttached)));
    }

    return pWatcher;
}

/**
 *	This method sents whether or not this component is attached.
 */
void Logger::Component::commandAttached(bool value)
{
    if (!value && g_pInstance_) {
        g_pInstance_->delComponent(this);
    }
}

BW_END_NAMESPACE

// logger.cpp
